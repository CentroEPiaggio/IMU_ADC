C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 1   


C51 COMPILER V9.51, COMPILATION OF MODULE SPI_IMU
OBJECT MODULE PLACED IN .\DP8051_Keil_951\Debug\SPI_IMU.obj
COMPILER INVOKED BY: C:\Program Files (x86)\Cypress\PSoC Creator\4.2\PSoC Creator\import\keil\pk51\9.51\C51\BIN\c51.exe 
                    -Generated_Source\PSoC3\SPI_IMU.c NOIV LARGE MODDP2 OMF2 VB(1) NOIP INCDIR(.,Generated_Source\PSoC3) FF(3) DB WL(2) PR(.\
                    -DP8051_Keil_951\Debug/SPI_IMU.lst) CD OT(2,SIZE) OJ(.\DP8051_Keil_951\Debug\SPI_IMU.obj)

line level    source

   1          /*******************************************************************************
   2          * File Name: SPI_IMU.c
   3          * Version 2.50
   4          *
   5          * Description:
   6          *  This file provides all API functionality of the SPI Master component.
   7          *
   8          * Note:
   9          *  None.
  10          *
  11          ********************************************************************************
  12          * Copyright 2008-2015, Cypress Semiconductor Corporation.  All rights reserved.
  13          * You may use this file only in accordance with the license, terms, conditions,
  14          * disclaimers, and limitations in the end user license agreement accompanying
  15          * the software package with which this file was provided.
  16          *******************************************************************************/
  17          
  18          #include "SPI_IMU_PVT.h"
  19          
  20          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED)
                  volatile uint8 SPI_IMU_txBuffer[SPI_IMU_TX_BUFFER_SIZE];
                  volatile uint8 SPI_IMU_txBufferFull;
                  volatile uint8 SPI_IMU_txBufferRead;
                  volatile uint8 SPI_IMU_txBufferWrite;
              #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
  26          
  27          #if(SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
                  volatile uint8 SPI_IMU_rxBuffer[SPI_IMU_RX_BUFFER_SIZE];
                  volatile uint8 SPI_IMU_rxBufferFull;
                  volatile uint8 SPI_IMU_rxBufferRead;
                  volatile uint8 SPI_IMU_rxBufferWrite;
              #endif /* (SPI_IMU_RX_SOFTWARE_BUF_ENABLED) */
  33          
  34          uint8 SPI_IMU_initVar = 0u;
  35          
  36          volatile uint8 SPI_IMU_swStatusTx;
  37          volatile uint8 SPI_IMU_swStatusRx;
  38          
  39          
  40          /*******************************************************************************
  41          * Function Name: SPI_IMU_Init
  42          ********************************************************************************
  43          *
  44          * Summary:
  45          *  Inits/Restores default SPIM configuration provided with customizer.
  46          *
  47          * Parameters:
  48          *  None.
  49          *
  50          * Return:
  51          *  None.
  52          *
  53          * Side Effects:
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 2   

  54          *  When this function is called it initializes all of the necessary parameters
  55          *  for execution. i.e. setting the initial interrupt mask, configuring the
  56          *  interrupt service routine, configuring the bit-counter parameters and
  57          *  clearing the FIFO and Status Register.
  58          *
  59          * Reentrant:
  60          *  No.
  61          *
  62          *******************************************************************************/
  63          void SPI_IMU_Init(void) 
  64          {
  65   1          /* Initialize the Bit counter */
  66   1          SPI_IMU_COUNTER_PERIOD_REG = SPI_IMU_BITCTR_INIT;
  67   1      
  68   1          /* Init TX ISR  */
  69   1          #if(0u != SPI_IMU_INTERNAL_TX_INT_ENABLED)
                      CyIntDisable         (SPI_IMU_TX_ISR_NUMBER);
                      CyIntSetPriority     (SPI_IMU_TX_ISR_NUMBER,  SPI_IMU_TX_ISR_PRIORITY);
                      (void) CyIntSetVector(SPI_IMU_TX_ISR_NUMBER, &SPI_IMU_TX_ISR);
                  #endif /* (0u != SPI_IMU_INTERNAL_TX_INT_ENABLED) */
  74   1      
  75   1          /* Init RX ISR  */
  76   1          #if(0u != SPI_IMU_INTERNAL_RX_INT_ENABLED)
                      CyIntDisable         (SPI_IMU_RX_ISR_NUMBER);
                      CyIntSetPriority     (SPI_IMU_RX_ISR_NUMBER,  SPI_IMU_RX_ISR_PRIORITY);
                      (void) CyIntSetVector(SPI_IMU_RX_ISR_NUMBER, &SPI_IMU_RX_ISR);
                  #endif /* (0u != SPI_IMU_INTERNAL_RX_INT_ENABLED) */
  81   1      
  82   1          /* Clear any stray data from the RX and TX FIFO */
  83   1          SPI_IMU_ClearFIFO();
  84   1      
  85   1          #if(SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
                      SPI_IMU_rxBufferFull  = 0u;
                      SPI_IMU_rxBufferRead  = 0u;
                      SPI_IMU_rxBufferWrite = 0u;
                  #endif /* (SPI_IMU_RX_SOFTWARE_BUF_ENABLED) */
  90   1      
  91   1          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED)
                      SPI_IMU_txBufferFull  = 0u;
                      SPI_IMU_txBufferRead  = 0u;
                      SPI_IMU_txBufferWrite = 0u;
                  #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
  96   1      
  97   1          (void) SPI_IMU_ReadTxStatus(); /* Clear Tx status and swStatusTx */
  98   1          (void) SPI_IMU_ReadRxStatus(); /* Clear Rx status and swStatusRx */
  99   1      
 100   1          /* Configure TX and RX interrupt mask */
 101   1          SPI_IMU_TX_STATUS_MASK_REG = SPI_IMU_TX_INIT_INTERRUPTS_MASK;
 102   1          SPI_IMU_RX_STATUS_MASK_REG = SPI_IMU_RX_INIT_INTERRUPTS_MASK;
 103   1      }
 104          
 105          
 106          /*******************************************************************************
 107          * Function Name: SPI_IMU_Enable
 108          ********************************************************************************
 109          *
 110          * Summary:
 111          *  Enable SPIM component.
 112          *
 113          * Parameters:
 114          *  None.
 115          *
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 3   

 116          * Return:
 117          *  None.
 118          *
 119          *******************************************************************************/
 120          void SPI_IMU_Enable(void) 
 121          {
 122   1          uint8 enableInterrupts;
 123   1      
 124   1          enableInterrupts = CyEnterCriticalSection();
 125   1          SPI_IMU_COUNTER_CONTROL_REG |= SPI_IMU_CNTR_ENABLE;
 126   1          SPI_IMU_TX_STATUS_ACTL_REG  |= SPI_IMU_INT_ENABLE;
 127   1          SPI_IMU_RX_STATUS_ACTL_REG  |= SPI_IMU_INT_ENABLE;
 128   1          CyExitCriticalSection(enableInterrupts);
 129   1      
 130   1          #if(0u != SPI_IMU_INTERNAL_CLOCK)
 131   1              SPI_IMU_IntClock_Enable();
 132   1          #endif /* (0u != SPI_IMU_INTERNAL_CLOCK) */
 133   1      
 134   1          SPI_IMU_EnableTxInt();
 135   1          SPI_IMU_EnableRxInt();
 136   1      }
 137          
 138          
 139          /*******************************************************************************
 140          * Function Name: SPI_IMU_Start
 141          ********************************************************************************
 142          *
 143          * Summary:
 144          *  Initialize and Enable the SPI Master component.
 145          *
 146          * Parameters:
 147          *  None.
 148          *
 149          * Return:
 150          *  None.
 151          *
 152          * Global variables:
 153          *  SPI_IMU_initVar - used to check initial configuration, modified on
 154          *  first function call.
 155          *
 156          * Theory:
 157          *  Enable the clock input to enable operation.
 158          *
 159          * Reentrant:
 160          *  No.
 161          *
 162          *******************************************************************************/
 163          void SPI_IMU_Start(void) 
 164          {
 165   1          if(0u == SPI_IMU_initVar)
 166   1          {
 167   2              SPI_IMU_Init();
 168   2              SPI_IMU_initVar = 1u;
 169   2          }
 170   1      
 171   1          SPI_IMU_Enable();
 172   1      }
 173          
 174          
 175          /*******************************************************************************
 176          * Function Name: SPI_IMU_Stop
 177          ********************************************************************************
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 4   

 178          *
 179          * Summary:
 180          *  Disable the SPI Master component.
 181          *
 182          * Parameters:
 183          *  None.
 184          *
 185          * Return:
 186          *  None.
 187          *
 188          * Theory:
 189          *  Disable the clock input to enable operation.
 190          *
 191          *******************************************************************************/
 192          void SPI_IMU_Stop(void) 
 193          {
 194   1          uint8 enableInterrupts;
 195   1      
 196   1          enableInterrupts = CyEnterCriticalSection();
 197   1          SPI_IMU_TX_STATUS_ACTL_REG &= ((uint8) ~SPI_IMU_INT_ENABLE);
 198   1          SPI_IMU_RX_STATUS_ACTL_REG &= ((uint8) ~SPI_IMU_INT_ENABLE);
 199   1          CyExitCriticalSection(enableInterrupts);
 200   1      
 201   1          #if(0u != SPI_IMU_INTERNAL_CLOCK)
 202   1              SPI_IMU_IntClock_Disable();
 203   1          #endif /* (0u != SPI_IMU_INTERNAL_CLOCK) */
 204   1      
 205   1          SPI_IMU_DisableTxInt();
 206   1          SPI_IMU_DisableRxInt();
 207   1      }
 208          
 209          
 210          /*******************************************************************************
 211          * Function Name: SPI_IMU_EnableTxInt
 212          ********************************************************************************
 213          *
 214          * Summary:
 215          *  Enable internal Tx interrupt generation.
 216          *
 217          * Parameters:
 218          *  None.
 219          *
 220          * Return:
 221          *  None.
 222          *
 223          * Theory:
 224          *  Enable the internal Tx interrupt output -or- the interrupt component itself.
 225          *
 226          *******************************************************************************/
 227          void SPI_IMU_EnableTxInt(void) 
 228          {
 229   1          #if(0u != SPI_IMU_INTERNAL_TX_INT_ENABLED)
                      CyIntEnable(SPI_IMU_TX_ISR_NUMBER);
                  #endif /* (0u != SPI_IMU_INTERNAL_TX_INT_ENABLED) */
 232   1      }
 233          
 234          
 235          /*******************************************************************************
 236          * Function Name: SPI_IMU_EnableRxInt
 237          ********************************************************************************
 238          *
 239          * Summary:
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 5   

 240          *  Enable internal Rx interrupt generation.
 241          *
 242          * Parameters:
 243          *  None.
 244          *
 245          * Return:
 246          *  None.
 247          *
 248          * Theory:
 249          *  Enable the internal Rx interrupt output -or- the interrupt component itself.
 250          *
 251          *******************************************************************************/
 252          void SPI_IMU_EnableRxInt(void) 
 253          {
 254   1          #if(0u != SPI_IMU_INTERNAL_RX_INT_ENABLED)
                      CyIntEnable(SPI_IMU_RX_ISR_NUMBER);
                  #endif /* (0u != SPI_IMU_INTERNAL_RX_INT_ENABLED) */
 257   1      }
 258          
 259          
 260          /*******************************************************************************
 261          * Function Name: SPI_IMU_DisableTxInt
 262          ********************************************************************************
 263          *
 264          * Summary:
 265          *  Disable internal Tx interrupt generation.
 266          *
 267          * Parameters:
 268          *  None.
 269          *
 270          * Return:
 271          *  None.
 272          *
 273          * Theory:
 274          *  Disable the internal Tx interrupt output -or- the interrupt component itself.
 275          *
 276          *******************************************************************************/
 277          void SPI_IMU_DisableTxInt(void) 
 278          {
 279   1          #if(0u != SPI_IMU_INTERNAL_TX_INT_ENABLED)
                      CyIntDisable(SPI_IMU_TX_ISR_NUMBER);
                  #endif /* (0u != SPI_IMU_INTERNAL_TX_INT_ENABLED) */
 282   1      }
 283          
 284          
 285          /*******************************************************************************
 286          * Function Name: SPI_IMU_DisableRxInt
 287          ********************************************************************************
 288          *
 289          * Summary:
 290          *  Disable internal Rx interrupt generation.
 291          *
 292          * Parameters:
 293          *  None.
 294          *
 295          * Return:
 296          *  None.
 297          *
 298          * Theory:
 299          *  Disable the internal Rx interrupt output -or- the interrupt component itself.
 300          *
 301          *******************************************************************************/
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 6   

 302          void SPI_IMU_DisableRxInt(void) 
 303          {
 304   1          #if(0u != SPI_IMU_INTERNAL_RX_INT_ENABLED)
                      CyIntDisable(SPI_IMU_RX_ISR_NUMBER);
                  #endif /* (0u != SPI_IMU_INTERNAL_RX_INT_ENABLED) */
 307   1      }
 308          
 309          
 310          /*******************************************************************************
 311          * Function Name: SPI_IMU_SetTxInterruptMode
 312          ********************************************************************************
 313          *
 314          * Summary:
 315          *  Configure which status bits trigger an interrupt event.
 316          *
 317          * Parameters:
 318          *  intSrc: An or'd combination of the desired status bit masks (defined in the
 319          *  header file).
 320          *
 321          * Return:
 322          *  None.
 323          *
 324          * Theory:
 325          *  Enables the output of specific status bits to the interrupt controller.
 326          *
 327          *******************************************************************************/
 328          void SPI_IMU_SetTxInterruptMode(uint8 intSrc) 
 329          {
 330   1          SPI_IMU_TX_STATUS_MASK_REG = intSrc;
 331   1      }
 332          
 333          
 334          /*******************************************************************************
 335          * Function Name: SPI_IMU_SetRxInterruptMode
 336          ********************************************************************************
 337          *
 338          * Summary:
 339          *  Configure which status bits trigger an interrupt event.
 340          *
 341          * Parameters:
 342          *  intSrc: An or'd combination of the desired status bit masks (defined in the
 343          *  header file).
 344          *
 345          * Return:
 346          *  None.
 347          *
 348          * Theory:
 349          *  Enables the output of specific status bits to the interrupt controller.
 350          *
 351          *******************************************************************************/
 352          void SPI_IMU_SetRxInterruptMode(uint8 intSrc) 
 353          {
 354   1          SPI_IMU_RX_STATUS_MASK_REG  = intSrc;
 355   1      }
 356          
 357          
 358          /*******************************************************************************
 359          * Function Name: SPI_IMU_ReadTxStatus
 360          ********************************************************************************
 361          *
 362          * Summary:
 363          *  Read the Tx status register for the component.
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 7   

 364          *
 365          * Parameters:
 366          *  None.
 367          *
 368          * Return:
 369          *  Contents of the Tx status register.
 370          *
 371          * Global variables:
 372          *  SPI_IMU_swStatusTx - used to store in software status register,
 373          *  modified every function call - resets to zero.
 374          *
 375          * Theory:
 376          *  Allows the user and the API to read the Tx status register for error
 377          *  detection and flow control.
 378          *
 379          * Side Effects:
 380          *  Clear Tx status register of the component.
 381          *
 382          * Reentrant:
 383          *  No.
 384          *
 385          *******************************************************************************/
 386          uint8 SPI_IMU_ReadTxStatus(void) 
 387          {
 388   1          uint8 tmpStatus;
 389   1      
 390   1          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED)
                      /* Disable TX interrupt to protect global veriables */
                      SPI_IMU_DisableTxInt();
              
                      tmpStatus = SPI_IMU_GET_STATUS_TX(SPI_IMU_swStatusTx);
                      SPI_IMU_swStatusTx = 0u;
              
                      SPI_IMU_EnableTxInt();
              
                  #else
 400   1      
 401   1              tmpStatus = SPI_IMU_TX_STATUS_REG;
 402   1      
 403   1          #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
 404   1      
 405   1          return(tmpStatus);
 406   1      }
 407          
 408          
 409          /*******************************************************************************
 410          * Function Name: SPI_IMU_ReadRxStatus
 411          ********************************************************************************
 412          *
 413          * Summary:
 414          *  Read the Rx status register for the component.
 415          *
 416          * Parameters:
 417          *  None.
 418          *
 419          * Return:
 420          *  Contents of the Rx status register.
 421          *
 422          * Global variables:
 423          *  SPI_IMU_swStatusRx - used to store in software Rx status register,
 424          *  modified every function call - resets to zero.
 425          *
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 8   

 426          * Theory:
 427          *  Allows the user and the API to read the Rx status register for error
 428          *  detection and flow control.
 429          *
 430          * Side Effects:
 431          *  Clear Rx status register of the component.
 432          *
 433          * Reentrant:
 434          *  No.
 435          *
 436          *******************************************************************************/
 437          uint8 SPI_IMU_ReadRxStatus(void) 
 438          {
 439   1          uint8 tmpStatus;
 440   1      
 441   1          #if(SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
                      /* Disable RX interrupt to protect global veriables */
                      SPI_IMU_DisableRxInt();
              
                      tmpStatus = SPI_IMU_GET_STATUS_RX(SPI_IMU_swStatusRx);
                      SPI_IMU_swStatusRx = 0u;
              
                      SPI_IMU_EnableRxInt();
              
                  #else
 451   1      
 452   1              tmpStatus = SPI_IMU_RX_STATUS_REG;
 453   1      
 454   1          #endif /* (SPI_IMU_RX_SOFTWARE_BUF_ENABLED) */
 455   1      
 456   1          return(tmpStatus);
 457   1      }
 458          
 459          
 460          /*******************************************************************************
 461          * Function Name: SPI_IMU_WriteTxData
 462          ********************************************************************************
 463          *
 464          * Summary:
 465          *  Write a byte of data to be sent across the SPI.
 466          *
 467          * Parameters:
 468          *  txDataByte: The data value to send across the SPI.
 469          *
 470          * Return:
 471          *  None.
 472          *
 473          * Global variables:
 474          *  SPI_IMU_txBufferWrite - used for the account of the bytes which
 475          *  have been written down in the TX software buffer, modified every function
 476          *  call if TX Software Buffer is used.
 477          *  SPI_IMU_txBufferRead - used for the account of the bytes which
 478          *  have been read from the TX software buffer.
 479          *  SPI_IMU_txBuffer[SPI_IMU_TX_BUFFER_SIZE] - used to store
 480          *  data to sending, modified every function call if TX Software Buffer is used.
 481          *
 482          * Theory:
 483          *  Allows the user to transmit any byte of data in a single transfer.
 484          *
 485          * Side Effects:
 486          *  If this function is called again before the previous byte is finished then
 487          *  the next byte will be appended to the transfer with no time between
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 9   

 488          *  the byte transfers. Clear Tx status register of the component.
 489          *
 490          * Reentrant:
 491          *  No.
 492          *
 493          *******************************************************************************/
 494          void SPI_IMU_WriteTxData(uint8 txData) 
 495          {
 496   1          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED)
              
                      uint8 tempStatus;
                      uint8 tmpTxBufferRead;
              
                      /* Block if TX buffer is FULL: don't overwrite */
                      do
                      {
                          tmpTxBufferRead = SPI_IMU_txBufferRead;
                          if(0u == tmpTxBufferRead)
                          {
                              tmpTxBufferRead = (SPI_IMU_TX_BUFFER_SIZE - 1u);
                          }
                          else
                          {
                              tmpTxBufferRead--;
                          }
              
                      }while(tmpTxBufferRead == SPI_IMU_txBufferWrite);
              
                      /* Disable TX interrupt to protect global veriables */
                      SPI_IMU_DisableTxInt();
              
                      tempStatus = SPI_IMU_GET_STATUS_TX(SPI_IMU_swStatusTx);
                      SPI_IMU_swStatusTx = tempStatus;
              
              
                      if((SPI_IMU_txBufferRead == SPI_IMU_txBufferWrite) &&
                         (0u != (SPI_IMU_swStatusTx & SPI_IMU_STS_TX_FIFO_NOT_FULL)))
                      {
                          /* Put data element into the TX FIFO */
                          CY_SET_REG8(SPI_IMU_TXDATA_PTR, txData);
                      }
                      else
                      {
                          /* Add to the TX software buffer */
                          SPI_IMU_txBufferWrite++;
                          if(SPI_IMU_txBufferWrite >= SPI_IMU_TX_BUFFER_SIZE)
                          {
                              SPI_IMU_txBufferWrite = 0u;
                          }
              
                          if(SPI_IMU_txBufferWrite == SPI_IMU_txBufferRead)
                          {
                              SPI_IMU_txBufferRead++;
                              if(SPI_IMU_txBufferRead >= SPI_IMU_TX_BUFFER_SIZE)
                              {
                                  SPI_IMU_txBufferRead = 0u;
                              }
                              SPI_IMU_txBufferFull = 1u;
                          }
              
                          SPI_IMU_txBuffer[SPI_IMU_txBufferWrite] = txData;
              
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 10  

                          SPI_IMU_TX_STATUS_MASK_REG |= SPI_IMU_STS_TX_FIFO_NOT_FULL;
                      }
              
                      SPI_IMU_EnableTxInt();
              
                  #else
 556   1              /* Wait until TX FIFO has a place */
 557   1              while(0u == (SPI_IMU_TX_STATUS_REG & SPI_IMU_STS_TX_FIFO_NOT_FULL))
 558   1              {
 559   2              }
 560   1      
 561   1              /* Put data element into the TX FIFO */
 562   1              CY_SET_REG8(SPI_IMU_TXDATA_PTR, txData);
 563   1      
 564   1          #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
 565   1      }
 566          
 567          
 568          /*******************************************************************************
 569          * Function Name: SPI_IMU_ReadRxData
 570          ********************************************************************************
 571          *
 572          * Summary:
 573          *  Read the next byte of data received across the SPI.
 574          *
 575          * Parameters:
 576          *  None.
 577          *
 578          * Return:
 579          *  The next byte of data read from the FIFO.
 580          *
 581          * Global variables:
 582          *  SPI_IMU_rxBufferWrite - used for the account of the bytes which
 583          *  have been written down in the RX software buffer.
 584          *  SPI_IMU_rxBufferRead - used for the account of the bytes which
 585          *  have been read from the RX software buffer, modified every function
 586          *  call if RX Software Buffer is used.
 587          *  SPI_IMU_rxBuffer[SPI_IMU_RX_BUFFER_SIZE] - used to store
 588          *  received data.
 589          *
 590          * Theory:
 591          *  Allows the user to read a byte of data received.
 592          *
 593          * Side Effects:
 594          *  Will return invalid data if the FIFO is empty. The user should Call
 595          *  GetRxBufferSize() and if it returns a non-zero value then it is safe to call
 596          *  ReadByte() function.
 597          *
 598          * Reentrant:
 599          *  No.
 600          *
 601          *******************************************************************************/
 602          uint8 SPI_IMU_ReadRxData(void) 
 603          {
 604   1          uint8 rxData;
 605   1      
 606   1          #if(SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
              
                      /* Disable RX interrupt to protect global veriables */
                      SPI_IMU_DisableRxInt();
              
                      if(SPI_IMU_rxBufferRead != SPI_IMU_rxBufferWrite)
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 11  

                      {
                          if(0u == SPI_IMU_rxBufferFull)
                          {
                              SPI_IMU_rxBufferRead++;
                              if(SPI_IMU_rxBufferRead >= SPI_IMU_RX_BUFFER_SIZE)
                              {
                                  SPI_IMU_rxBufferRead = 0u;
                              }
                          }
                          else
                          {
                              SPI_IMU_rxBufferFull = 0u;
                          }
                      }
              
                      rxData = SPI_IMU_rxBuffer[SPI_IMU_rxBufferRead];
              
                      SPI_IMU_EnableRxInt();
              
                  #else
 632   1      
 633   1              rxData = CY_GET_REG8(SPI_IMU_RXDATA_PTR);
 634   1      
 635   1          #endif /* (SPI_IMU_RX_SOFTWARE_BUF_ENABLED) */
 636   1      
 637   1          return(rxData);
 638   1      }
 639          
 640          
 641          /*******************************************************************************
 642          * Function Name: SPI_IMU_GetRxBufferSize
 643          ********************************************************************************
 644          *
 645          * Summary:
 646          *  Returns the number of bytes/words of data currently held in the RX buffer.
 647          *  If RX Software Buffer not used then function return 0 if FIFO empty or 1 if
 648          *  FIFO not empty. In another case function return size of RX Software Buffer.
 649          *
 650          * Parameters:
 651          *  None.
 652          *
 653          * Return:
 654          *  Integer count of the number of bytes/words in the RX buffer.
 655          *
 656          * Global variables:
 657          *  SPI_IMU_rxBufferWrite - used for the account of the bytes which
 658          *  have been written down in the RX software buffer.
 659          *  SPI_IMU_rxBufferRead - used for the account of the bytes which
 660          *  have been read from the RX software buffer.
 661          *
 662          * Side Effects:
 663          *  Clear status register of the component.
 664          *
 665          *******************************************************************************/
 666          uint8 SPI_IMU_GetRxBufferSize(void) 
 667          {
 668   1          uint8 size;
 669   1      
 670   1          #if(SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
              
                      /* Disable RX interrupt to protect global veriables */
                      SPI_IMU_DisableRxInt();
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 12  

              
                      if(SPI_IMU_rxBufferRead == SPI_IMU_rxBufferWrite)
                      {
                          size = 0u;
                      }
                      else if(SPI_IMU_rxBufferRead < SPI_IMU_rxBufferWrite)
                      {
                          size = (SPI_IMU_rxBufferWrite - SPI_IMU_rxBufferRead);
                      }
                      else
                      {
                          size = (SPI_IMU_RX_BUFFER_SIZE - SPI_IMU_rxBufferRead) + SPI_IMU_rxBufferWrite;
                      }
              
                      SPI_IMU_EnableRxInt();
              
                  #else
 691   1      
 692   1              /* We can only know if there is data in the RX FIFO */
 693   1              size = (0u != (SPI_IMU_RX_STATUS_REG & SPI_IMU_STS_RX_FIFO_NOT_EMPTY)) ? 1u : 0u;
 694   1      
 695   1          #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
 696   1      
 697   1          return(size);
 698   1      }
 699          
 700          
 701          /*******************************************************************************
 702          * Function Name: SPI_IMU_GetTxBufferSize
 703          ********************************************************************************
 704          *
 705          * Summary:
 706          *  Returns the number of bytes/words of data currently held in the TX buffer.
 707          *  If TX Software Buffer not used then function return 0 - if FIFO empty, 1 - if
 708          *  FIFO not full, 4 - if FIFO full. In another case function return size of TX
 709          *  Software Buffer.
 710          *
 711          * Parameters:
 712          *  None.
 713          *
 714          * Return:
 715          *  Integer count of the number of bytes/words in the TX buffer.
 716          *
 717          * Global variables:
 718          *  SPI_IMU_txBufferWrite - used for the account of the bytes which
 719          *  have been written down in the TX software buffer.
 720          *  SPI_IMU_txBufferRead - used for the account of the bytes which
 721          *  have been read from the TX software buffer.
 722          *
 723          * Side Effects:
 724          *  Clear status register of the component.
 725          *
 726          *******************************************************************************/
 727          uint8  SPI_IMU_GetTxBufferSize(void) 
 728          {
 729   1          uint8 size;
 730   1      
 731   1          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED)
                      /* Disable TX interrupt to protect global veriables */
                      SPI_IMU_DisableTxInt();
              
                      if(SPI_IMU_txBufferRead == SPI_IMU_txBufferWrite)
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 13  

                      {
                          size = 0u;
                      }
                      else if(SPI_IMU_txBufferRead < SPI_IMU_txBufferWrite)
                      {
                          size = (SPI_IMU_txBufferWrite - SPI_IMU_txBufferRead);
                      }
                      else
                      {
                          size = (SPI_IMU_TX_BUFFER_SIZE - SPI_IMU_txBufferRead) + SPI_IMU_txBufferWrite;
                      }
              
                      SPI_IMU_EnableTxInt();
              
                  #else
 751   1      
 752   1              size = SPI_IMU_TX_STATUS_REG;
 753   1      
 754   1              if(0u != (size & SPI_IMU_STS_TX_FIFO_EMPTY))
 755   1              {
 756   2                  size = 0u;
 757   2              }
 758   1              else if(0u != (size & SPI_IMU_STS_TX_FIFO_NOT_FULL))
 759   1              {
 760   2                  size = 1u;
 761   2              }
 762   1              else
 763   1              {
 764   2                  size = SPI_IMU_FIFO_SIZE;
 765   2              }
 766   1      
 767   1          #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
 768   1      
 769   1          return(size);
 770   1      }
 771          
 772          
 773          /*******************************************************************************
 774          * Function Name: SPI_IMU_ClearRxBuffer
 775          ********************************************************************************
 776          *
 777          * Summary:
 778          *  Clear the RX RAM buffer by setting the read and write pointers both to zero.
 779          *
 780          * Parameters:
 781          *  None.
 782          *
 783          * Return:
 784          *  None.
 785          *
 786          * Global variables:
 787          *  SPI_IMU_rxBufferWrite - used for the account of the bytes which
 788          *  have been written down in the RX software buffer, modified every function
 789          *  call - resets to zero.
 790          *  SPI_IMU_rxBufferRead - used for the account of the bytes which
 791          *  have been read from the RX software buffer, modified every function call -
 792          *  resets to zero.
 793          *
 794          * Theory:
 795          *  Setting the pointers to zero makes the system believe there is no data to
 796          *  read and writing will resume at address 0 overwriting any data that may have
 797          *  remained in the RAM.
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 14  

 798          *
 799          * Side Effects:
 800          *  Any received data not read from the RAM buffer will be lost when overwritten.
 801          *
 802          * Reentrant:
 803          *  No.
 804          *
 805          *******************************************************************************/
 806          void SPI_IMU_ClearRxBuffer(void) 
 807          {
 808   1          /* Clear Hardware RX FIFO */
 809   1          while(0u !=(SPI_IMU_RX_STATUS_REG & SPI_IMU_STS_RX_FIFO_NOT_EMPTY))
 810   1          {
 811   2              (void) CY_GET_REG8(SPI_IMU_RXDATA_PTR);
 812   2          }
 813   1      
 814   1          #if(SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
                      /* Disable RX interrupt to protect global veriables */
                      SPI_IMU_DisableRxInt();
              
                      SPI_IMU_rxBufferFull  = 0u;
                      SPI_IMU_rxBufferRead  = 0u;
                      SPI_IMU_rxBufferWrite = 0u;
              
                      SPI_IMU_EnableRxInt();
                  #endif /* (SPI_IMU_RX_SOFTWARE_BUF_ENABLED) */
 824   1      }
 825          
 826          
 827          /*******************************************************************************
 828          * Function Name: SPI_IMU_ClearTxBuffer
 829          ********************************************************************************
 830          *
 831          * Summary:
 832          *  Clear the TX RAM buffer by setting the read and write pointers both to zero.
 833          *
 834          * Parameters:
 835          *  None.
 836          *
 837          * Return:
 838          *  None.
 839          *
 840          * Global variables:
 841          *  SPI_IMU_txBufferWrite - used for the account of the bytes which
 842          *  have been written down in the TX software buffer, modified every function
 843          *  call - resets to zero.
 844          *  SPI_IMU_txBufferRead - used for the account of the bytes which
 845          *  have been read from the TX software buffer, modified every function call -
 846          *  resets to zero.
 847          *
 848          * Theory:
 849          *  Setting the pointers to zero makes the system believe there is no data to
 850          *  read and writing will resume at address 0 overwriting any data that may have
 851          *  remained in the RAM.
 852          *
 853          * Side Effects:
 854          *  Any data not yet transmitted from the RAM buffer will be lost when
 855          *  overwritten.
 856          *
 857          * Reentrant:
 858          *  No.
 859          *
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 15  

 860          *******************************************************************************/
 861          void SPI_IMU_ClearTxBuffer(void) 
 862          {
 863   1          uint8 enableInterrupts;
 864   1      
 865   1          enableInterrupts = CyEnterCriticalSection();
 866   1          /* Clear TX FIFO */
 867   1          SPI_IMU_AUX_CONTROL_DP0_REG |= ((uint8)  SPI_IMU_TX_FIFO_CLR);
 868   1          SPI_IMU_AUX_CONTROL_DP0_REG &= ((uint8) ~SPI_IMU_TX_FIFO_CLR);
 869   1      
 870   1          #if(SPI_IMU_USE_SECOND_DATAPATH)
                      /* Clear TX FIFO for 2nd Datapath */
                      SPI_IMU_AUX_CONTROL_DP1_REG |= ((uint8)  SPI_IMU_TX_FIFO_CLR);
                      SPI_IMU_AUX_CONTROL_DP1_REG &= ((uint8) ~SPI_IMU_TX_FIFO_CLR);
                  #endif /* (SPI_IMU_USE_SECOND_DATAPATH) */
 875   1          CyExitCriticalSection(enableInterrupts);
 876   1      
 877   1          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED)
                      /* Disable TX interrupt to protect global veriables */
                      SPI_IMU_DisableTxInt();
              
                      SPI_IMU_txBufferFull  = 0u;
                      SPI_IMU_txBufferRead  = 0u;
                      SPI_IMU_txBufferWrite = 0u;
              
                      /* Buffer is EMPTY: disable TX FIFO NOT FULL interrupt */
                      SPI_IMU_TX_STATUS_MASK_REG &= ((uint8) ~SPI_IMU_STS_TX_FIFO_NOT_FULL);
              
                      SPI_IMU_EnableTxInt();
                  #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED) */
 890   1      }
 891          
 892          
 893          #if(0u != SPI_IMU_BIDIRECTIONAL_MODE)
                  /*******************************************************************************
                  * Function Name: SPI_IMU_TxEnable
                  ********************************************************************************
                  *
                  * Summary:
                  *  If the SPI master is configured to use a single bi-directional pin then this
                  *  will set the bi-directional pin to transmit.
                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void SPI_IMU_TxEnable(void) 
                  {
                      SPI_IMU_CONTROL_REG |= SPI_IMU_CTRL_TX_SIGNAL_EN;
                  }
              
              
                  /*******************************************************************************
                  * Function Name: SPI_IMU_TxDisable
                  ********************************************************************************
                  *
                  * Summary:
                  *  If the SPI master is configured to use a single bi-directional pin then this
                  *  will set the bi-directional pin to receive.
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 16  

                  *
                  * Parameters:
                  *  None.
                  *
                  * Return:
                  *  None.
                  *
                  *******************************************************************************/
                  void SPI_IMU_TxDisable(void) 
                  {
                      SPI_IMU_CONTROL_REG &= ((uint8) ~SPI_IMU_CTRL_TX_SIGNAL_EN);
                  }
              
              #endif /* (0u != SPI_IMU_BIDIRECTIONAL_MODE) */
 936          
 937          
 938          /*******************************************************************************
 939          * Function Name: SPI_IMU_PutArray
 940          ********************************************************************************
 941          *
 942          * Summary:
 943          *  Write available data from ROM/RAM to the TX buffer while space is available
 944          *  in the TX buffer. Keep trying until all data is passed to the TX buffer.
 945          *
 946          * Parameters:
 947          *  *buffer: Pointer to the location in RAM containing the data to send
 948          *  byteCount: The number of bytes to move to the transmit buffer.
 949          *
 950          * Return:
 951          *  None.
 952          *
 953          * Side Effects:
 954          *  Will stay in this routine until all data has been sent.  May get locked in
 955          *  this loop if data is not being initiated by the master if there is not
 956          *  enough room in the TX FIFO.
 957          *
 958          * Reentrant:
 959          *  No.
 960          *
 961          *******************************************************************************/
 962          void SPI_IMU_PutArray(const uint8 buffer[], uint8 byteCount)
 963                                                                                    
 964          {
 965   1          uint8 bufIndex;
 966   1      
 967   1          bufIndex = 0u;
 968   1      
 969   1          while(byteCount > 0u)
 970   1          {
 971   2              SPI_IMU_WriteTxData(buffer[bufIndex]);
 972   2              bufIndex++;
 973   2              byteCount--;
 974   2          }
 975   1      }
 976          
 977          
 978          /*******************************************************************************
 979          * Function Name: SPI_IMU_ClearFIFO
 980          ********************************************************************************
 981          *
 982          * Summary:
 983          *  Clear the RX and TX FIFO's of all data for a fresh start.
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 17  

 984          *
 985          * Parameters:
 986          *  None.
 987          *
 988          * Return:
 989          *  None.
 990          *
 991          * Side Effects:
 992          *  Clear status register of the component.
 993          *
 994          *******************************************************************************/
 995          void SPI_IMU_ClearFIFO(void) 
 996          {
 997   1          uint8 enableInterrupts;
 998   1      
 999   1          /* Clear Hardware RX FIFO */
1000   1          while(0u !=(SPI_IMU_RX_STATUS_REG & SPI_IMU_STS_RX_FIFO_NOT_EMPTY))
1001   1          {
1002   2              (void) CY_GET_REG8(SPI_IMU_RXDATA_PTR);
1003   2          }
1004   1      
1005   1          enableInterrupts = CyEnterCriticalSection();
1006   1          /* Clear TX FIFO */
1007   1          SPI_IMU_AUX_CONTROL_DP0_REG |= ((uint8)  SPI_IMU_TX_FIFO_CLR);
1008   1          SPI_IMU_AUX_CONTROL_DP0_REG &= ((uint8) ~SPI_IMU_TX_FIFO_CLR);
1009   1      
1010   1          #if(SPI_IMU_USE_SECOND_DATAPATH)
                      /* Clear TX FIFO for 2nd Datapath */
                      SPI_IMU_AUX_CONTROL_DP1_REG |= ((uint8)  SPI_IMU_TX_FIFO_CLR);
                      SPI_IMU_AUX_CONTROL_DP1_REG &= ((uint8) ~SPI_IMU_TX_FIFO_CLR);
                  #endif /* (SPI_IMU_USE_SECOND_DATAPATH) */
1015   1          CyExitCriticalSection(enableInterrupts);
1016   1      }
1017          
1018          
1019          /* Following functions are for version Compatibility, they are obsolete.
1020          *  Please do not use it in new projects.
1021          */
1022          
1023          
1024          /*******************************************************************************
1025          * Function Name: SPI_IMU_EnableInt
1026          ********************************************************************************
1027          *
1028          * Summary:
1029          *  Enable internal interrupt generation.
1030          *
1031          * Parameters:
1032          *  None.
1033          *
1034          * Return:
1035          *  None.
1036          *
1037          * Theory:
1038          *  Enable the internal interrupt output -or- the interrupt component itself.
1039          *
1040          *******************************************************************************/
1041          void SPI_IMU_EnableInt(void) 
1042          {
1043   1          SPI_IMU_EnableRxInt();
1044   1          SPI_IMU_EnableTxInt();
1045   1      }
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 18  

1046          
1047          
1048          /*******************************************************************************
1049          * Function Name: SPI_IMU_DisableInt
1050          ********************************************************************************
1051          *
1052          * Summary:
1053          *  Disable internal interrupt generation.
1054          *
1055          * Parameters:
1056          *  None.
1057          *
1058          * Return:
1059          *  None.
1060          *
1061          * Theory:
1062          *  Disable the internal interrupt output -or- the interrupt component itself.
1063          *
1064          *******************************************************************************/
1065          void SPI_IMU_DisableInt(void) 
1066          {
1067   1          SPI_IMU_DisableTxInt();
1068   1          SPI_IMU_DisableRxInt();
1069   1      }
1070          
1071          
1072          /*******************************************************************************
1073          * Function Name: SPI_IMU_SetInterruptMode
1074          ********************************************************************************
1075          *
1076          * Summary:
1077          *  Configure which status bits trigger an interrupt event.
1078          *
1079          * Parameters:
1080          *  intSrc: An or'd combination of the desired status bit masks (defined in the
1081          *  header file).
1082          *
1083          * Return:
1084          *  None.
1085          *
1086          * Theory:
1087          *  Enables the output of specific status bits to the interrupt controller.
1088          *
1089          *******************************************************************************/
1090          void SPI_IMU_SetInterruptMode(uint8 intSrc) 
1091          {
1092   1          SPI_IMU_TX_STATUS_MASK_REG  = (intSrc & ((uint8) ~SPI_IMU_STS_SPI_IDLE));
1093   1          SPI_IMU_RX_STATUS_MASK_REG  =  intSrc;
1094   1      }
1095          
1096          
1097          /*******************************************************************************
1098          * Function Name: SPI_IMU_ReadStatus
1099          ********************************************************************************
1100          *
1101          * Summary:
1102          *  Read the status register for the component.
1103          *
1104          * Parameters:
1105          *  None.
1106          *
1107          * Return:
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 19  

1108          *  Contents of the status register.
1109          *
1110          * Global variables:
1111          *  SPI_IMU_swStatus - used to store in software status register,
1112          *  modified every function call - resets to zero.
1113          *
1114          * Theory:
1115          *  Allows the user and the API to read the status register for error detection
1116          *  and flow control.
1117          *
1118          * Side Effects:
1119          *  Clear status register of the component.
1120          *
1121          * Reentrant:
1122          *  No.
1123          *
1124          *******************************************************************************/
1125          uint8 SPI_IMU_ReadStatus(void) 
1126          {
1127   1          uint8 tmpStatus;
1128   1      
1129   1          #if(SPI_IMU_TX_SOFTWARE_BUF_ENABLED || SPI_IMU_RX_SOFTWARE_BUF_ENABLED)
              
                      SPI_IMU_DisableInt();
              
                      tmpStatus  = SPI_IMU_GET_STATUS_RX(SPI_IMU_swStatusRx);
                      tmpStatus |= SPI_IMU_GET_STATUS_TX(SPI_IMU_swStatusTx);
                      tmpStatus &= ((uint8) ~SPI_IMU_STS_SPI_IDLE);
              
                      SPI_IMU_swStatusTx = 0u;
                      SPI_IMU_swStatusRx = 0u;
              
                      SPI_IMU_EnableInt();
              
                  #else
1143   1      
1144   1              tmpStatus  = SPI_IMU_RX_STATUS_REG;
1145   1              tmpStatus |= SPI_IMU_TX_STATUS_REG;
1146   1              tmpStatus &= ((uint8) ~SPI_IMU_STS_SPI_IDLE);
1147   1      
1148   1          #endif /* (SPI_IMU_TX_SOFTWARE_BUF_ENABLED || SPI_IMU_RX_SOFTWARE_BUF_ENABLED) */
1149   1      
1150   1          return(tmpStatus);
1151   1      }
1152          
1153          
1154          /* [] END OF FILE */
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 20  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION SPI_IMU_Init (BEGIN)
                                           ; SOURCE LINE # 63
                                           ; SOURCE LINE # 64
                                           ; SOURCE LINE # 66
0000 906587            MOV     DPTR,#06587H
0003 740F              MOV     A,#0FH
0005 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 83
0006 120000      R     LCALL   SPI_IMU_ClearFIFO
                                           ; SOURCE LINE # 97
0009 120000      R     LCALL   SPI_IMU_ReadTxStatus
                                           ; SOURCE LINE # 98
000C 120000      R     LCALL   SPI_IMU_ReadRxStatus
                                           ; SOURCE LINE # 101
000F 90648B            MOV     DPTR,#0648BH
0012 E4                CLR     A
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 102
0014 90648F            MOV     DPTR,#0648FH
0017 E4                CLR     A
0018 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 103
0019 22                RET     
             ; FUNCTION SPI_IMU_Init (END)

             ; FUNCTION SPI_IMU_Enable (BEGIN)
                                           ; SOURCE LINE # 120
                                           ; SOURCE LINE # 121
                                           ; SOURCE LINE # 124
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 125
0008 906597            MOV     DPTR,#06597H
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4420              ORL     A,#020H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 126
0013 90649B            MOV     DPTR,#0649BH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 4410              ORL     A,#010H
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 127
001E 90649F            MOV     DPTR,#0649FH
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 EF                MOV     A,R7
0024 4410              ORL     A,#010H
0026 FF                MOV     R7,A
0027 EF                MOV     A,R7
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 21  

0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 128
0029 900000      R     MOV     DPTR,#enableInterrupts
002C E0                MOVX    A,@DPTR
002D FF                MOV     R7,A
002E 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 131
0031 120000      E     LCALL   SPI_IMU_IntClock_Start
                                           ; SOURCE LINE # 134
0034 120000      R     LCALL   SPI_IMU_EnableTxInt
                                           ; SOURCE LINE # 135
0037 120000      R     LCALL   SPI_IMU_EnableRxInt
                                           ; SOURCE LINE # 136
003A 22                RET     
             ; FUNCTION SPI_IMU_Enable (END)

             ; FUNCTION SPI_IMU_Start (BEGIN)
                                           ; SOURCE LINE # 163
                                           ; SOURCE LINE # 164
                                           ; SOURCE LINE # 165
0000 900000      R     MOV     DPTR,#SPI_IMU_initVar
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 7009              JNZ     ?C0003
                                           ; SOURCE LINE # 166
                                           ; SOURCE LINE # 167
0008 120000      R     LCALL   SPI_IMU_Init
                                           ; SOURCE LINE # 168
000B 900000      R     MOV     DPTR,#SPI_IMU_initVar
000E 7401              MOV     A,#01H
0010 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 169
0011         ?C0003:
                                           ; SOURCE LINE # 171
0011 120000      R     LCALL   SPI_IMU_Enable
                                           ; SOURCE LINE # 172
0014 22                RET     
             ; FUNCTION SPI_IMU_Start (END)

             ; FUNCTION SPI_IMU_Stop (BEGIN)
                                           ; SOURCE LINE # 192
                                           ; SOURCE LINE # 193
                                           ; SOURCE LINE # 196
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 197
0008 90649B            MOV     DPTR,#0649BH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 54EF              ANL     A,#0EFH
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 198
0013 90649F            MOV     DPTR,#0649FH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 22  

0019 54EF              ANL     A,#0EFH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 199
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 202
0026 120000      E     LCALL   SPI_IMU_IntClock_Stop
                                           ; SOURCE LINE # 205
0029 120000      R     LCALL   SPI_IMU_DisableTxInt
                                           ; SOURCE LINE # 206
002C 120000      R     LCALL   SPI_IMU_DisableRxInt
                                           ; SOURCE LINE # 207
002F 22                RET     
             ; FUNCTION SPI_IMU_Stop (END)

             ; FUNCTION SPI_IMU_EnableTxInt (BEGIN)
                                           ; SOURCE LINE # 227
                                           ; SOURCE LINE # 228
                                           ; SOURCE LINE # 232
0000 22                RET     
             ; FUNCTION SPI_IMU_EnableTxInt (END)

             ; FUNCTION SPI_IMU_EnableRxInt (BEGIN)
                                           ; SOURCE LINE # 252
                                           ; SOURCE LINE # 253
                                           ; SOURCE LINE # 257
0000 22                RET     
             ; FUNCTION SPI_IMU_EnableRxInt (END)

             ; FUNCTION SPI_IMU_DisableTxInt (BEGIN)
                                           ; SOURCE LINE # 277
                                           ; SOURCE LINE # 278
                                           ; SOURCE LINE # 282
0000 22                RET     
             ; FUNCTION SPI_IMU_DisableTxInt (END)

             ; FUNCTION SPI_IMU_DisableRxInt (BEGIN)
                                           ; SOURCE LINE # 302
                                           ; SOURCE LINE # 303
                                           ; SOURCE LINE # 307
0000 22                RET     
             ; FUNCTION SPI_IMU_DisableRxInt (END)

             ; FUNCTION _SPI_IMU_SetTxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 328
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 329
                                           ; SOURCE LINE # 330
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648B            MOV     DPTR,#0648BH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 331
000F 22                RET     
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 23  

             ; FUNCTION _SPI_IMU_SetTxInterruptMode (END)

             ; FUNCTION _SPI_IMU_SetRxInterruptMode (BEGIN)
                                           ; SOURCE LINE # 352
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 353
                                           ; SOURCE LINE # 354
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A 90648F            MOV     DPTR,#0648FH
000D EF                MOV     A,R7
000E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 355
000F 22                RET     
             ; FUNCTION _SPI_IMU_SetRxInterruptMode (END)

             ; FUNCTION SPI_IMU_ReadTxStatus (BEGIN)
                                           ; SOURCE LINE # 386
                                           ; SOURCE LINE # 387
                                           ; SOURCE LINE # 401
0000 90646B            MOV     DPTR,#0646BH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#tmpStatus
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 405
000A 900000      R     MOV     DPTR,#tmpStatus
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 406
000F         ?C0012:
000F 22                RET     
             ; FUNCTION SPI_IMU_ReadTxStatus (END)

             ; FUNCTION SPI_IMU_ReadRxStatus (BEGIN)
                                           ; SOURCE LINE # 437
                                           ; SOURCE LINE # 438
                                           ; SOURCE LINE # 452
0000 90646F            MOV     DPTR,#0646FH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#tmpStatus
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 456
000A 900000      R     MOV     DPTR,#tmpStatus
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 457
000F         ?C0013:
000F 22                RET     
             ; FUNCTION SPI_IMU_ReadRxStatus (END)

             ; FUNCTION _SPI_IMU_WriteTxData (BEGIN)
                                           ; SOURCE LINE # 494
0000 900000      R     MOV     DPTR,#txData
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 24  

                                           ; SOURCE LINE # 495
0005         ?C0014:
                                           ; SOURCE LINE # 557
0005 90646B            MOV     DPTR,#0646BH
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 30E2F7            JNB     ACC.2,?C0014
                                           ; SOURCE LINE # 558
                                           ; SOURCE LINE # 559
000E         ?C0015:
                                           ; SOURCE LINE # 562
000E 900000      R     MOV     DPTR,#txData
0011 E0                MOVX    A,@DPTR
0012 FF                MOV     R7,A
0013 90644B            MOV     DPTR,#0644BH
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 565
0018 22                RET     
             ; FUNCTION _SPI_IMU_WriteTxData (END)

             ; FUNCTION SPI_IMU_ReadRxData (BEGIN)
                                           ; SOURCE LINE # 602
                                           ; SOURCE LINE # 603
                                           ; SOURCE LINE # 633
0000 90645B            MOV     DPTR,#0645BH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#rxData
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 637
000A 900000      R     MOV     DPTR,#rxData
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
                                           ; SOURCE LINE # 638
000F         ?C0017:
000F 22                RET     
             ; FUNCTION SPI_IMU_ReadRxData (END)

             ; FUNCTION SPI_IMU_GetRxBufferSize (BEGIN)
                                           ; SOURCE LINE # 666
                                           ; SOURCE LINE # 667
                                           ; SOURCE LINE # 693
0000 90646F            MOV     DPTR,#0646FH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E504            JNB     ACC.5,?C0018
0009 7F01              MOV     R7,#01H
000B 8002              SJMP    ?C0019
000D         ?C0018:
000D 7F00              MOV     R7,#00H
000F         ?C0019:
000F 900000      R     MOV     DPTR,#size
0012 EF                MOV     A,R7
0013 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 697
0014 900000      R     MOV     DPTR,#size
0017 E0                MOVX    A,@DPTR
0018 FF                MOV     R7,A
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 25  

                                           ; SOURCE LINE # 698
0019         ?C0020:
0019 22                RET     
             ; FUNCTION SPI_IMU_GetRxBufferSize (END)

             ; FUNCTION SPI_IMU_GetTxBufferSize (BEGIN)
                                           ; SOURCE LINE # 727
                                           ; SOURCE LINE # 728
                                           ; SOURCE LINE # 752
0000 90646B            MOV     DPTR,#0646BH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#size
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 754
000A 900000      R     MOV     DPTR,#size
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F EF                MOV     A,R7
0010 30E107            JNB     ACC.1,?C0021
                                           ; SOURCE LINE # 755
                                           ; SOURCE LINE # 756
0013 900000      R     MOV     DPTR,#size
0016 E4                CLR     A
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 757
0018 8017              SJMP    ?C0022
001A         ?C0021:
                                           ; SOURCE LINE # 758
001A 900000      R     MOV     DPTR,#size
001D E0                MOVX    A,@DPTR
001E FF                MOV     R7,A
001F EF                MOV     A,R7
0020 30E208            JNB     ACC.2,?C0023
                                           ; SOURCE LINE # 759
                                           ; SOURCE LINE # 760
0023 900000      R     MOV     DPTR,#size
0026 7401              MOV     A,#01H
0028 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 761
0029 8006              SJMP    ?C0022
002B         ?C0023:
                                           ; SOURCE LINE # 763
                                           ; SOURCE LINE # 764
002B 900000      R     MOV     DPTR,#size
002E 7404              MOV     A,#04H
0030 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 765
0031         ?C0022:
                                           ; SOURCE LINE # 769
0031 900000      R     MOV     DPTR,#size
0034 E0                MOVX    A,@DPTR
0035 FF                MOV     R7,A
                                           ; SOURCE LINE # 770
0036         ?C0025:
0036 22                RET     
             ; FUNCTION SPI_IMU_GetTxBufferSize (END)

             ; FUNCTION SPI_IMU_ClearRxBuffer (BEGIN)
                                           ; SOURCE LINE # 806
                                           ; SOURCE LINE # 807
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 26  

0000         ?C0026:
                                           ; SOURCE LINE # 809
0000 90646F            MOV     DPTR,#0646FH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E507            JNB     ACC.5,?C0028
                                           ; SOURCE LINE # 810
                                           ; SOURCE LINE # 811
0009 90645B            MOV     DPTR,#0645BH
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
                                           ; SOURCE LINE # 812
000E 80F0              SJMP    ?C0026
                                           ; SOURCE LINE # 824
0010         ?C0028:
0010 22                RET     
             ; FUNCTION SPI_IMU_ClearRxBuffer (END)

             ; FUNCTION SPI_IMU_ClearTxBuffer (BEGIN)
                                           ; SOURCE LINE # 861
                                           ; SOURCE LINE # 862
                                           ; SOURCE LINE # 865
0000 120000      E     LCALL   CyEnterCriticalSection
0003 900000      R     MOV     DPTR,#enableInterrupts
0006 EF                MOV     A,R7
0007 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 867
0008 90649B            MOV     DPTR,#0649BH
000B E0                MOVX    A,@DPTR
000C FF                MOV     R7,A
000D EF                MOV     A,R7
000E 4401              ORL     A,#01H
0010 FF                MOV     R7,A
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 868
0013 90649B            MOV     DPTR,#0649BH
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 EF                MOV     A,R7
0019 54FE              ANL     A,#0FEH
001B FF                MOV     R7,A
001C EF                MOV     A,R7
001D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 875
001E 900000      R     MOV     DPTR,#enableInterrupts
0021 E0                MOVX    A,@DPTR
0022 FF                MOV     R7,A
0023 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 890
0026 22                RET     
             ; FUNCTION SPI_IMU_ClearTxBuffer (END)

             ; FUNCTION _SPI_IMU_PutArray (BEGIN)
                                           ; SOURCE LINE # 962
0000 900000      R     MOV     DPTR,#buffer
0003 120000      E     LCALL   ?C?PSTXDATA
0006 900000      R     MOV     DPTR,#byteCount
0009 ED                MOV     A,R5
000A F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 964
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 27  

                                           ; SOURCE LINE # 967
000B 900000      R     MOV     DPTR,#bufIndex
000E E4                CLR     A
000F F0                MOVX    @DPTR,A
0010         ?C0030:
                                           ; SOURCE LINE # 969
0010 900000      R     MOV     DPTR,#byteCount
0013 E0                MOVX    A,@DPTR
0014 FF                MOV     R7,A
0015 EF                MOV     A,R7
0016 D3                SETB    C
0017 9400              SUBB    A,#00H
0019 4026              JC      ?C0032
                                           ; SOURCE LINE # 970
                                           ; SOURCE LINE # 971
001B 900000      R     MOV     DPTR,#buffer
001E 120000      E     LCALL   ?C?PLDXDATA
0021 900000      R     MOV     DPTR,#bufIndex
0024 E0                MOVX    A,@DPTR
0025 FF                MOV     R7,A
0026 E9                MOV     A,R1
0027 2F                ADD     A,R7
0028 F9                MOV     R1,A
0029 E4                CLR     A
002A 3A                ADDC    A,R2
002B FA                MOV     R2,A
002C 120000      E     LCALL   ?C?CLDPTR
002F FF                MOV     R7,A
0030 120000      R     LCALL   _SPI_IMU_WriteTxData
                                           ; SOURCE LINE # 972
0033 900000      R     MOV     DPTR,#bufIndex
0036 E0                MOVX    A,@DPTR
0037 04                INC     A
0038 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 973
0039 900000      R     MOV     DPTR,#byteCount
003C E0                MOVX    A,@DPTR
003D 14                DEC     A
003E F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 974
003F 80CF              SJMP    ?C0030
                                           ; SOURCE LINE # 975
0041         ?C0032:
0041 22                RET     
             ; FUNCTION _SPI_IMU_PutArray (END)

             ; FUNCTION SPI_IMU_ClearFIFO (BEGIN)
                                           ; SOURCE LINE # 995
                                           ; SOURCE LINE # 996
0000         ?C0033:
                                           ; SOURCE LINE # 1000
0000 90646F            MOV     DPTR,#0646FH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 EF                MOV     A,R7
0006 30E507            JNB     ACC.5,?C0034
                                           ; SOURCE LINE # 1001
                                           ; SOURCE LINE # 1002
0009 90645B            MOV     DPTR,#0645BH
000C E0                MOVX    A,@DPTR
000D FF                MOV     R7,A
                                           ; SOURCE LINE # 1003
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 28  

000E 80F0              SJMP    ?C0033
0010         ?C0034:
                                           ; SOURCE LINE # 1005
0010 120000      E     LCALL   CyEnterCriticalSection
0013 900000      R     MOV     DPTR,#enableInterrupts
0016 EF                MOV     A,R7
0017 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1007
0018 90649B            MOV     DPTR,#0649BH
001B E0                MOVX    A,@DPTR
001C FF                MOV     R7,A
001D EF                MOV     A,R7
001E 4401              ORL     A,#01H
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1008
0023 90649B            MOV     DPTR,#0649BH
0026 E0                MOVX    A,@DPTR
0027 FF                MOV     R7,A
0028 EF                MOV     A,R7
0029 54FE              ANL     A,#0FEH
002B FF                MOV     R7,A
002C EF                MOV     A,R7
002D F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1015
002E 900000      R     MOV     DPTR,#enableInterrupts
0031 E0                MOVX    A,@DPTR
0032 FF                MOV     R7,A
0033 120000      E     LCALL   _CyExitCriticalSection
                                           ; SOURCE LINE # 1016
0036 22                RET     
             ; FUNCTION SPI_IMU_ClearFIFO (END)

             ; FUNCTION SPI_IMU_EnableInt (BEGIN)
                                           ; SOURCE LINE # 1041
                                           ; SOURCE LINE # 1042
                                           ; SOURCE LINE # 1043
0000 120000      R     LCALL   SPI_IMU_EnableRxInt
                                           ; SOURCE LINE # 1044
0003 120000      R     LCALL   SPI_IMU_EnableTxInt
                                           ; SOURCE LINE # 1045
0006 22                RET     
             ; FUNCTION SPI_IMU_EnableInt (END)

             ; FUNCTION SPI_IMU_DisableInt (BEGIN)
                                           ; SOURCE LINE # 1065
                                           ; SOURCE LINE # 1066
                                           ; SOURCE LINE # 1067
0000 120000      R     LCALL   SPI_IMU_DisableTxInt
                                           ; SOURCE LINE # 1068
0003 120000      R     LCALL   SPI_IMU_DisableRxInt
                                           ; SOURCE LINE # 1069
0006 22                RET     
             ; FUNCTION SPI_IMU_DisableInt (END)

             ; FUNCTION _SPI_IMU_SetInterruptMode (BEGIN)
                                           ; SOURCE LINE # 1090
0000 900000      R     MOV     DPTR,#intSrc
0003 EF                MOV     A,R7
0004 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1091
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 29  

                                           ; SOURCE LINE # 1092
0005 900000      R     MOV     DPTR,#intSrc
0008 E0                MOVX    A,@DPTR
0009 FF                MOV     R7,A
000A EF                MOV     A,R7
000B 54EF              ANL     A,#0EFH
000D FF                MOV     R7,A
000E 90648B            MOV     DPTR,#0648BH
0011 EF                MOV     A,R7
0012 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1093
0013 900000      R     MOV     DPTR,#intSrc
0016 E0                MOVX    A,@DPTR
0017 FF                MOV     R7,A
0018 90648F            MOV     DPTR,#0648FH
001B EF                MOV     A,R7
001C F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1094
001D 22                RET     
             ; FUNCTION _SPI_IMU_SetInterruptMode (END)

             ; FUNCTION SPI_IMU_ReadStatus (BEGIN)
                                           ; SOURCE LINE # 1125
                                           ; SOURCE LINE # 1126
                                           ; SOURCE LINE # 1144
0000 90646F            MOV     DPTR,#0646FH
0003 E0                MOVX    A,@DPTR
0004 FF                MOV     R7,A
0005 900000      R     MOV     DPTR,#tmpStatus
0008 EF                MOV     A,R7
0009 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1145
000A 900000      R     MOV     DPTR,#tmpStatus
000D E0                MOVX    A,@DPTR
000E FF                MOV     R7,A
000F 90646B            MOV     DPTR,#0646BH
0012 E0                MOVX    A,@DPTR
0013 FE                MOV     R6,A
0014 EF                MOV     A,R7
0015 4E                ORL     A,R6
0016 FF                MOV     R7,A
0017 900000      R     MOV     DPTR,#tmpStatus
001A EF                MOV     A,R7
001B F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1146
001C 900000      R     MOV     DPTR,#tmpStatus
001F E0                MOVX    A,@DPTR
0020 FF                MOV     R7,A
0021 EF                MOV     A,R7
0022 54EF              ANL     A,#0EFH
0024 FF                MOV     R7,A
0025 900000      R     MOV     DPTR,#tmpStatus
0028 EF                MOV     A,R7
0029 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 1150
002A 900000      R     MOV     DPTR,#tmpStatus
002D E0                MOVX    A,@DPTR
002E FF                MOV     R7,A
                                           ; SOURCE LINE # 1151
002F         ?C0039:
002F 22                RET     
             ; FUNCTION SPI_IMU_ReadStatus (END)
C51 COMPILER V9.51   SPI_IMU                                                               04/01/2019 12:07:53 PAGE 30  




MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    613    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =      3      19
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
   EDATA SIZE       =   ----    ----
   HDATA SIZE       =   ----    ----
   XDATA CONST SIZE =   ----    ----
   FAR CONST SIZE   =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
